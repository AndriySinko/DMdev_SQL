------------------------------------- Day 7 ---------------------------------------------


-------------- Lesson 1,2 -----------------------

/**
  Урок 1. Планы выполнения запросов в индексах:

  1.Самая базовая операция – это последовательное сканирование (Seq Scan).
  Это самая простая операция из всех возможных – PostgreSQL открывает файл с таблицей,
  читает строки одну за другой и возвращает их пользователю или расположенному выше узлу дерева explain

  2.Следующий тип узла — “Index Scan".
  Всё просто – у нас есть индекс, соответствующий условию, так что PostgreSQL:
    - Открывает индекс;
    - В индексе, если находит, где (в данных таблицы) могут быть строки, соответствующие данному условию:
        - открывает таблицу;
        - получает строку(-и), указанную(-ые) индексом;
    - Если строки могут быть возвращены – то есть, если они видимы в текущей сессии – они возвращаются.

  3.Ещё одна схожая операция — “Index Only Scan".
  Обратите внимание на слово “Only" в “Index Only Scan".
  Это значит, что Постгрес понял, что я выбираю только данные (колонки) из индекса.
  И, возможно, ему не нужно ничего проверять в файлах таблицы. Так что он будет возвращать данные прямо из индекса.

  4.Последний тип сканирования таблицы – так называемый Bitmap Index Scan.
  Bitmap Scans всегда состоят, минимум, из двух узлов. Сначала (на нижнем уровне) идет Bitmap Index Scan,
  а затем – Bitmap Heap Scan.

  Допустим, в вашей таблице 100000 страниц (это около 780MB). Bitmap Index Scan создаст битовую карту,
  где каждой странице вашей таблицы будет соответствовать один бит.
  Так что, в этом случае мы получим блок памяти на 100,000 бит ~ 12.5 кБ. Все эти биты будут установлены в 0.
  Затем, Bitmap Index Scan установит некоторые биты в 1, в зависимости от того,
  на какой странице таблицы может находиться строка, которую нужно вернуть.

  Эта часть вообще не затрагивает данные в таблице. После того как это будет сделано – то есть когда все страницы,
  на которых находятся строки, которые нужно вернуть, будут «помечены» – эта битовая карта перейдет на уровень выше,
  к узлу Bitmap Heap Scan, который читает их в более последовательной манере.


  Урок 2. Планы выполнения запросов в джоинах:

  1.Hash Join / Hash
  Hash Join имеет 2 субоперации. Одна из них всегда “Hash", а вторая – что-нибудь другое.
  Как понятно из названия, Hash Join используется для объединения двух наборов записей.

  Сначала Hash Join вызывает “Hash", который в свою очередь вызывает что-нибудь ещё.
  Потом Hash создает в памяти (или на диске – в зависимости от размера) хэш/ассоциативный массив/словарь со строками
  из источника, хэшированными с помощью того, что используется для объединения данных.

  Потом Hash Join запускает вторую субоперацию (Seq Scan по pg_class в нашем случае) и, для каждой строки из неё, делает следующее:
    - Проверяет, есть ли ключ join в хэше, возвращенном операцией Hash.
    - Если нет, данная строка из субоперации игнорируется (не будет возвращена).
    - Если ключ существует, Hash Join берет строки из хэша и, основываясь на этой строке, с одной стороны,
      и всех строках хэша, с другой стороны, генерирует вывод строк.

 Важно отметить, что обе стороны join выполняются всего один раз, но сначала та, что была вызвана операцией Hash,
 должна вернуть все строки, которые хранились в хэше, а вторая обрабатывается построчно,
 и некоторые строки будут пропущены, если они не существуют в хэше первой стороны.

  2.Nested Loop
  Это очень интересный план, потому что он может выполнять выбранные операции неоднократно.
  Так же, как и у Hash Join, у Nested Loop есть двое «потомков». Сначала она запускает “Seq Scan",
  а затем, для каждой возвращенной строки, она запускает вторую операцию.

  Давайте рассмотрим следующий план из explain.depesz.com.
  Заметьте, что фактическое время выполнения для всех операций index scan для categories – от 0.002 до 0.003мс.
  Но общее время, затраченное на этот узел – 78.852мс, потому что это сканирование индекса выполнялось более 26k раз.

 Так что обработка выглядит следующим образом:
    - Nested Loop запускает первую сторону объединения единожды. Давайте назовем её “A".
    - Для каждой строки из “A", запускается вторая операция (назовём её “B").
    - Если “B" не вернула ни одной строки, данные из “A" игнорируются.
    - Если “B" вернула строки, для каждой возвращаемой строки Nested Loop возвращает новую строку,
      основанную на текущих строках из A и B.

  3.Merge Join
  Еще один метод объединения данных называется Merge Join. Он используется, если объединяемые наборы данных отсортированы
  (или могут быть отсортированы с небольшими затратами) с помощью ключа join.

  Merge Join, как и другие объединения, запускает две субоперации.
  Так как они обе возвращают данные отсортированными и порядок сортировки такой же, как в операции объединения,
  Pg может сканировать оба набора данных, возвращенных субоперациями, одновременно и просто проверить,
  совпадают ли идентификаторы.

Процедура выглядит следующим образом:
    Eсли объединяемый столбец справа такой же, как объединяемый столбец слева:
        - возвращаем новую объединённую строку, основанную на текущих строках справа и слева;
        - берем следующую строку справа (или слева, если справа больше нет строк);
        - возвращаемся к шагу 1;
    Eсли объединяемый столбец справа «меньше», чем объединяемый столбец слева:
        - берем следующую строку справа (если строк больше нет, заканчиваем обработку);
        - возвращаемся к шагу 1;
    Eсли объединяемый столбец справа «больше», чем объединяемый столбец слева:
        - берем следующую строку слева (если строк больше нет, заканчиваем обработку);
        - возвращаемся к шагу 1.
 */
