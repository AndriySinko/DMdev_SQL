/*
В базах данных существует такие понятия как DDL и DML
Если приводить в пример Excel, то:

DDL используется для создания, и управления базой данных - имеет 3 оснвные функции:
CREATE - используется для создания схемы, таблицы, базы данных
DROP - используется для удаления схемы, таблицы, базы данных
ALTER - используется для изменения схемы, таблицы, базы данных

DML используется для манипулирования данных в базе данных - имеет 4 основнык функции:
INSERT - добавление новых строк
DELETE - удаление строк
UPDATE - изменение строк
SELECT - используется для выборки данных в базе

По конвенции sql все ключевые слова должны писатся заглавными буквами, назания маленьки и через знак " _ "
но самой базе данных все равно на регистр
 */

CREATE DATABASE conclusion;
CREATE SCHEMA schema_elementary;

/*
 В sql как и в других языках програмирования присутствуют типы данных:

 Числа:
 Целые:
 smallint   2 байта
 integer    4 байта
 bigint	    8 байт
 smallserial	2 байта - с автоувеличением
 serial	        4 байта - с автоувеличением
 bigserial      8 байт  - с автоувеличением
 Вещественные:
 decimal	        переменный - вещественное число с указанной точностью
 numeric	        переменный - вещественное число с указанной точностью
 real	            4 байта    - вещественное число с переменной точностью
 double precision	8 байт	   - вещественное число с переменной точностью

 Строки в '':
 Строки фиксированой длинны: character(n) - char(n)
 Строки переменной длинны: character varying(n) - varchar(n)
 Текст: TEXT

 Время:
 Дата: date
 Время: time
 Дата и время: timestamp

 Лошический тип:
 BOOLEAN

 -----------------------------------------------------

 Когда мы создаем таблицу в ней мы можем указать какие данные(строки, колонки) в ней будут находится, и к ним
 мы можнм добавить какие-то ограничения (CONSTRAINT):
 NOT NULL - не = 0
 UNIQUE - на целую таблицу будет только 1 такая колонка
 CHECK -  задает ограничение для диапазона значений, которые могут храниться в столбце
 PRIMARY KEY - первичный ключ, обьеденяет в себе NOT NULL, UNIQUE,
 FOREIGN KEY - внешний ключ
 */

CREATE TABLE people
(
    id                SERIAL PRIMARY KEY,
    first_name        VARCHAR(128) NOT NULL,
    last_name         VARCHAR(128) NOT NULL,
    people_years      INT          NOT NULL,
    birthday          DATE         NOT NULL,
    availability_work BOOLEAN      NOT NULL,
    salary            INT
);


/**
  Чтобы добавить в таблицу столбцы мы должны написать INSERT INTO (что мы будт вставлять)
    VALUES (значения)
 */

INSERT INTO people (first_name, last_name, people_years, birthday, availability_work, salary)
VALUES ('Anrii', 'Synko', 16, '25-02-2007', TRUE, 3000),
       ('Jakub', 'Varga', 20, '20-01-2007', TRUE, 1500),
       ('Ruslan', 'Prodan', 30, '21-06-2004', TRUE, 1000),
       ('Ruslan', 'Ursta', 22, '5-02-2005', TRUE, 2000),
       ('Anton', 'Penzeshtadler', 36, '04-07-2009', TRUE, 1200),
       ('Andriy', 'Jancikn', 54, '24-09-2005', TRUE, 800),
       ('Matey', 'Slnek', 40, '16-04-2001', TRUE, 600),
       ('Tomas', 'Moravcik', 10, '11-02-1997', FALSE, NULL),
       ('Tomas', 'Labar', 25, '23-11-2006', FALSE, NULL),
       ('Danil', 'Atukmaiev', 33, '05-10-1990', FALSE, NULL);


/*
 Чтобы получить данные из таблицы мы используем SELECT что мы хочем получить FROM название таблицы, условия

 Условия получения данных из таблицы могут быть разными:
 DISTINCT - возвращает уникальные обьекты, если в таблице есть повторяющтеся
 LIMIT число - ограничивает кол-во возвращаемых записей
 OFFSET число - пропускает указаное кол-во записей, и выводит остальные
 ORDER BY значение - сортирует нашу таблицу в порядке возрастания ASC, и спадания DESC

 Еще столбцу и целой таблице можно назначить имя (имя которое выведется в консоль)
 если посл указаного столбца поставить проблем или ключевое слово AS

 SELECT * - возвращает все столбцы из таблицы
 */

SELECT first_name   имя,
       last_name    фамилия,
       people_years возраст,
       birthday     дата_рождения
FROM people
ORDER BY people_years DESC
OFFSET 3 LIMIT 5;

SELECT *
FROM people;


/*
 Так-же выборки с помощью SELECT можно филтровать ключевым словом WHERE

 С WHERE мы можем использовать операторы = == <>; +=; >=; <=;

 Со строками можно использовать LIKE но оно не берет во внимение регистр,
 тогда если нам нужно брать во внимание регистр то мы используем ILIKE.

 С помощью знака % можно указывать префиксы и постфиксы, напрмер если слово начинает на A% или заканчивается на %I

 BETWEEN - диапазон

 Если мы ищем именно какие-то определенные данные то используем IN()

 OR - или; AND - и; IS - является; Приоритер AND выше чем OR
 */

SELECT *
FROM people
WHERE people_years > 30;

SELECT *
FROM people
WHERE first_name ILIKE 'A%'
   OR last_name LIKE '%r';

SELECT *
FROM people
WHERE salary BETWEEN 1000 AND 2000;

SELECT *
FROM people
WHERE availability_work IS FALSE;

SELECT *
FROM people
WHERE birthday IN ('25-02-2007')
   OR (first_name ILIKE 'Matey' AND last_name ILIKE 'Slnek');


/*
 В sql так же как и в джава есть свои функции
 sum() - возвращает сумму всех записей тех полей которые мы указали в параметры,
 min() - возвращает минимальное поле среди всех записей тех полей которые в параметрах,
 max() - возвращает максимальное поле среди всех записей тех полей которые в параметрах,
 avg() - возвращает среднее значение всех записей тех полей которые мы указали в параметры,
 count() - возвращает кол-во записей тех полей которые в параметрах, не учитывает null
* count(*) - возвращает кол-во всех записей

 upper() - возвращает строки в верхнем регистре
 lower() - возвращает строки в нижнем регистре
 concat() - обьеденяет и выводит строки в 1 поле
* concat() езе можем записать с помощью ||

 now() - возвращает дату
 */

SELECT count(*)                         количесвто_всех_людей,
       count(availability_work IS TRUE) работающие,
       count(availability_work IS TRUE) безработные,
       min(salary)                      минимальная_зарплата,
       max(salary)                      максимальная_зарплата,
       avg(salary)                      средняя_зарплата,
       avg(people_years)                средний_возраст
FROM people;

SELECT concat(first_name, ' ', last_name),
       upper(first_name),
       lower(last_name),
       now(),
       people_years || ' ' || birthday
FROM people;


/*
 Внешние ключи позволяют установить связи между таблицами. Внешний ключ устанавливается для столбцов из зависимой,
 подчиненной таблицы, и указывает на один из столбцов из главной таблицы. Как правило, внешний ключ указывает на
 первичный ключ из связанной главной таблицы.

 Для создания ограничения внешнего ключа после FOREIGN KEY указывается столбец таблицы, который будет представляет внешний ключ.
 А после ключевого слова REFERENCES указывается имя связанной таблицы, а затем в скобках имя связанного столбца,
 на который будет указывать внешний ключ. После выражения REFERENCES идут выражения ON DELETE и ON UPDATE,
 которые задают действие при удалении и обновлении строки из главной таблицы соответственно.

 С помощью выражений ON DELETE и ON UPDATE можно установить действия, которые выполняются соответственно при удалении и
 изменении связанной строки из главной таблицы. В качестве действия могут использоваться следующие опции:

 CASCADE: автоматически удаляет или изменяет строки из зависимой таблицы при удалении или изменении связанных строк
 в главной таблице.

 SET NULL: при удалении или обновлении связанной строки из главной таблицы устанавливает для столбца внешнего ключа
 значение NULL. (В этом случае столбец внешнего ключа должен поддерживать установку NULL)

 RESTRICT: отклоняет удаление или изменение строк в главной таблице при наличии связанных строк в зависимой таблице.

 NO ACTION: то же самое, что и RESTRICT.

 SET DEFAULT: при удалении связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение по
 умолчанию, которое задается с помощью атрибуты DEFAULT. Несмотря на то, что данная опция в принципе доступна,
 однако движок InnoDB не поддерживает данное выражение.
 */

CREATE TABLE company
(
    company_id          SERIAL PRIMARY KEY,
    company_name        TEXT UNIQUE NOT NULL,
    company_create_date DATE        NOT NULL,
    company_employee_id INT REFERENCES people ON DELETE CASCADE -- если мы ничего не указываем в параметры то будет братся ключ
    --employee_name TEXT,
    --FOREIGN KEY (employee_name) REFERENCES lesson_1 (first_name)
);

INSERT INTO company (company_name, company_create_date, company_employee_id)
VALUES ('Apple', '25-04-1990', 1),
       ('Google', '16-09-1995', 3),
       ('Uber', '05-12-2001', NULL),
       ('Amazon', '29-05-2005', 4),
       ('Facebook', '17-03-1992', 2);

SELECT *
FROM company;

/*
 Если у нас есть две таблицы, но у них есть каки-ето схожие поля, и если нам нужно вывести их вместе,
 то мы используем UNION или UNION ALL, их отличие только в том, что:
 UNION ALL выводит все поля одной и другой таюлицы, и ей все равно есть ли там дубликаты
 UNION выводит только уникальные элементы обоих таблиц
 */

SELECT *
FROM people
WHERE availability_work IS FALSE
UNION ALL
SELECT *
FROM people
WHERE salary < 1000;

SELECT *
FROM people
WHERE people_years > 25
UNION
SELECT *
FROM people
WHERE availability_work IS FALSE;


/*
 Подзапросы, это запросы внутри запросов, должны находится в скобках, и должен быть альяс.
 Они могут находится в:
 SELECT
 FROM
 WHERE
 */

SELECT avg(salary)
FROM (SELECT *
      FROM people
      WHERE salary > 1000) s;

SELECT *,
       (SELECT concat(first_name, ' ', last_name)
        FROM people
        WHERE id = company.company_employee_id) фио_работника
FROM company;

SELECT first_name || ' ' || last_name            фио,
       (SELECT max(salary) FROM people) - salary до_максимальной_зп,
       (SELECT avg(salary) FROM people)          средняя_зп
FROM people
WHERE salary > (SELECT avg(salary)
                FROM people);


/**
Так ж как и добавлять записи в таблицу, их можно оттуда удалять с помощью DELETE,
и регулировать то какие записи нужно удалить с помощью WHERE, а в нем можно использовать SELECT
Удалять мы можем только с 1 таблицы

RETURNING - возвращет нам строки которые мы изменили либо удалили

 */

DELETE
FROM people
WHERE first_name ILIKE 'A%';

DELETE
FROM people
WHERE availability_work IS FALSE
RETURNING *;

/*
Если в нашей таблице проихиошли какие-то изменения, то мы можем ее обновить, или даже изменить какие-то записи.
Для этого мы используем UPDATE name SET.
*/

UPDATE people
SET availability_work = FALSE
WHERE id = (SELECT company_id
            FROM company
            WHERE company_employee_id IS NULL)
RETURNING *;


/*
 Реляционные базы данных - это базы данных у которых есть связи между собой с помощью каких-то отношений.
 Эти связи(отношения) осуществляются за щет внешних ключей.

 Избиточность данных - это хранения одних и тех самых файлов в базе данных, но в разных местах,
 и это производит к разным аномалтям.

 Нормализация - это способ проектирования базы данных который привод к минимальной избыточности.
 Чтобы этого достичь мы используем нормальные формы баз данных.

 Нормлаьная форма базы данных - это набор привил, критериев которым база данных должна соответсвовать

 Перечень нормальных форм:
 1. Ненормализованая(нулевая формальная) (UNF)
 2. Первая нормальная (1NF)
 3. Вторая нормальная (2NF)
 3  Третья нормальная (3NF)
 4..
 5..

 Есть и остальные перечни, но обычно используются только эти, чтобы сохранить хорошою производительность.
 Каждая высшая нормальная форма содержит в себе предыдущие, то есть если у нас 2 форма, она будет содержать 1 и 0

 UNF - в базе творится не пойми-чтоЮ может быть дублироваие, неатомарные значения

 1NF - нацелена на соблюдение простейших правил:
    - В таблице не должно быть дублирования
    - Все столбцы должны быть атомарными(в них должно быть уложено только 1 значение)
    - В столбце хранятся данные только 1 типа

 2NF - нацелена на первичный ключ:
    - Таблтца должна находится в 1 номральной форме
    - Таблица должна иметь первичный ключ (PRIMARY KEY)
    - Все неключевые стоблцы (обчные столбцы, не ключевые) должны зависеть от
        полного первичного ключа (в случае если он составной) Составной первичный ключ - это
            комбинация 2 и больше первичный ключей, от которых зависит уникальность, но если же неключевым
                столбцам хватит для уникальности только 1 ключа, то остальные делать нельзя

 3NF - нацелен на неключевые столбцы:
    - Таблица должна находится во 2 нормальной форме
    - В таблице должна отсутсвовать транзитивная зависимость неключевых столбцов
        (нельзя чтобы неключевой столбец зависел от другого неключевого)
            Если нам все таки нужно установить связь, то нужно установить внешний ключ,
                который будет ссылатся на пераичный ключ другой таблицы, и тогда мы достигнем 3 нормальной формы

 Пример 3 нормальной формы:
 */

CREATE SCHEMA schema_base;
CREATE TABLE car
(
    id       SERIAL PRIMARY KEY,
    car_id   INT REFERENCES type_car,
    color    VARCHAR(128) NOT NULL,
    owner_id INT REFERENCES peoples,
    UNIQUE (car_id, owner_id)
);
CREATE TABLE type_car
(
    id          SERIAL PRIMARY KEY,
    brand_car   VARCHAR(128) NOT NULL,
    model_car   VARCHAR(128) NOT NULL,
    public_year INT          NOT NULL,
    UNIQUE (brand_car, model_car, public_year)
);

CREATE TABLE peoples
(
    id           SERIAL PRIMARY KEY,
    first_name   VARCHAR(128) NOT NULL,
    last_name    VARCHAR(128) NOT NULL,
    people_years INT          NOT NULL
);

/*
 Как уже упоминалось выше, связь между таблтцами устанавливется с помощью первичных ключей, и внеших,
 которые ссылаются на них

 Существует 3 вида связывания:

1.Многие ко многим:
    Представим, что нам нужно написать БД, которая будет хранить работником IT-компании.
    При этом существует некий стандартный набор должностей. При этом:

        - Работник может иметь одну и более должностей. Например, некий работник может быть и админом, и программистом.
        - Должность может «владеть» одним и более работников. Например, админами является определенный набор работников.
            Другими словами, к админам относятся некие работники.

    Чтобы реализовать такой тип связывания мы должны придти к данному способу:
        Мы уже имеем две таблицы, описывающие работника и профессию.
        Теперь нам нужно установить между ними связь многие ко многим.
        Для реализации такой связи нам нужен некий посредник между таблицами

    В нашем случае это будет некая таблица работников и должностей.
    Эта таблица-посредник связывает между собой работника и должность следующим образом:
        -Мы берем адйти роботника и вставляем и вставляем в таблицу как внешний ключ который ссылается на таблицу роботников
        -Мы берем айди должности и вставляем и вставляем в таблицу как внешний ключ который ссылается на таблицу должностей

    EmployeeId	PositionId
    1	        1
    1	        2
    2	        3
    3	        3

    Таким образом, мы говорим, что работник с id 1 находится на должность с id 1.
    При этом обратите внимание на то, что в этой таблице работник с id 1 имеет две должности: 1 и 2.
    Т.е., каждому работнику слева соответствует некая должность справа.

    И еще мытакже можем сказать, что должности с id 3 принадлежат пользователи с id 2 и 3.
    Т.е., каждой роли справа принадлежит некий работник слева.


2.Один к многоим:
    Предположим, нам нужно реализовать некую БД, которая ведет учет данных о пользователях.
    У пользователя есть: имя, фамилия, возраст, номера телефонов.
    При этом у каждого пользователя может быть от одного и больше номеров телефонов (многие номера телефонов).

    В этом случае мы наблюдаем следующее:
    пользователь может иметь многие номера телефонов, но нельзя сказать, что номеру телефона принадлежит определенный пользователь.
    Другими словами, телефон принадлежит только одному пользователю. А пользователю могут принадлежать 1 и более телефонов (многие).

 Чтобы реализовать такое тип связывания мы прибеагем к следующему:
    Пользователей будет представлять некая таблица «Person» (id, имя, фамилия, возраст),
    номера телефонов будет представлять таблица «Phone». Она будет выглядеть так:

        PhoneId 	PersonId	PhoneNumber
        1	        5	        11 091-10
        2	        5	        19 124-66
        3	        17	        21 972-02

    Данная таблица представляет три номера телефона.
    При этом номера телефона с id 1 и 2 принадлежат пользователю с id 5. А вот номер с id 3 принадлежит пользователю с id 17.


3.Один к одному:
 Представим, что на работе вам дали задание написать БД для учета всех работников для HR.
 Начальник уверял, что компании нужно знать только об имени, возрасте и телефоне работника.
 Вы разработали такую БД и поместили в нее всю 1000 работников компании.
 И тут начальник говорит, что им зачем-то нужно знать о том, является ли работник инвалидом или нет.
 Наиболее простое, что приходит в голову — это добавить новый столбец типа bool в вашу таблицу.
 Но это слишком долго вписывать 1000 значений и ведь true вы будете вписывать намного реже, чем false (2% будут true, например).

Более простым решением будет создать новую таблицу, назовем ее «DisabledEmployee». Она будет выглядеть так:

    DisabledPersonId	EmployeeId
    1	                159
    2	                722
    3	                937

    Но это еще не связь один к одному.
    Дело в том, что в такую таблицу работник может быть вписан более одного раза,
    соответственно, мы получили отношение один ко многим работник может быть несколько раз инвалидом.

 Нужно сделать так, чтобы работник мог быть вписан в таблицу только один раз, соответственно, мог быть инвалидом только один раз.
 Для этого нам нужно указать, что столбец EmployeeId может хранить только уникальные значения.
 Нам нужно просто наложить на столбец EmloyeeId ограничение unique или тоже сделать его primary key(уникальный и не = 0).
 Это ограничение сообщает, что атрибут может принимать только уникальные значения.
 Выполнив это мы получили связь один к одному.

*/

-- Многие ко многим:
CREATE TABLE job_title
(
    id    SERIAL PRIMARY KEY,
    title VARCHAR(128) NOT NULL UNIQUE
);

CREATE TABLE connect_title_employee
(
    employee_id INT REFERENCES peoples ON DELETE CASCADE ON UPDATE CASCADE,
    title_id    INT REFERENCES job_title ON DELETE CASCADE ON UPDATE CASCADE,
    UNIQUE (employee_id, title_id)
);

--Один к многим
CREATE TABLE phone
(
    id           SERIAL PRIMARY KEY,
    phone_number INT NOT NULL,
    person_id    INT REFERENCES peoples ON DELETE CASCADE ON UPDATE CASCADE
);

-- Один к одному
CREATE TABLE disabled_person
(
    id        SERIAL PRIMARY KEY,
    person_id INT REFERENCES peoples ON DELETE CASCADE ON UPDATE CASCADE UNIQUE
);


/*
Также соедениение таблиц можно осуществить с помощью
  1. INNER JOIN(JOIN) - отсекает все значение где внешний ключ ссылается на ключ = null, или наоборот
  2. CROSS JOIN - привод все элементы одной таблицы со всем другой(каждый с каждым)
  3. OUTER JOIN - полностью возвращает какую-то запись таблицы или целую таблицу, внезависимости от тогда ссылается ли
    какой-то элемент на null

Типы OUTER JOIN:
    - LEFT OUTER JOIN (LEFT JOIN) - показывает все записи справа от соеденения
    - RIGHT OUTER JOIN (RIGHT JOIN) - показывает все записи справа от соеденения
    - FULL OUTER JOIN (FULL JOIN) - показывает все соеденения
 */

CREATE TABLE company_1
(
    id          SERIAL PRIMARY KEY,
    name        TEXT UNIQUE NOT NULL,
    create_date DATE        NOT NULL
);

INSERT INTO company_1 (name, create_date)
VALUES ('Apple', '25-04-1990'),
       ('Google', '16-09-1995'),
       ('Uber', '05-12-2001'),
       ('Amazon', '29-05-2005'),
       ('Facebook', '17-03-1992');

CREATE TABLE person
(
    id           SERIAL PRIMARY KEY,
    first_name   VARCHAR(128) NOT NULL,
    last_name    VARCHAR(128) NOT NULL,
    people_years INT          NOT NULL,
    birthday     DATE         NOT NULL,
    company_id   INT REFERENCES company_1 ON DELETE CASCADE,
    salary       INT
);

INSERT INTO person (first_name, last_name, people_years, birthday, company_id, salary)
VALUES ('Anrii', 'Synko', 16, '25-02-2007', 1, 3000),
       ('Jakub', 'Varga', 20, '20-01-2007', 1, 1500),
       ('Ruslan', 'Prodan', 30, '21-06-2004', 2, 1000),
       ('Ruslan', 'Ursta', 22, '5-02-2005', 2, 2000),
       ('Anton', 'Penzeshtadler', 36, '04-07-2009', 3, 1200),
       ('Andriy', 'Jancikn', 54, '24-09-2005', 3, 800),
       ('Matey', 'Slnek', 40, '16-04-2001', 5, 600),
       ('Tomas', 'Moravcik', 10, '11-02-1997', 5, 1000),
       ('Tomas', 'Labar', 25, '23-11-2006', NULL, NULL),
       ('Danil', 'Atukmaiev', 33, '05-10-1990', NULL, NULL);

-- INNER JOIN
SELECT p.id,
       p.first_name || ' ' || p.last_name fio,
       c.id,
       c.name
FROM person p
         JOIN company_1 c
              ON c.id = p.company_id;

SELECT c.id,
       c.name,
       p.first_name || ' ' || p.last_name
FROM company_1 c
         JOIN person p
              ON c.id = p.company_id;

-- CROSS JOIN

SELECT c.name,
       p.first_name || ' ' || p.last_name
FROM company_1 c
         CROSS JOIN (SELECT * FROM person) p;

-- OUTER JOIN

SELECT first_name || ' ' || last_name,
       c.name
FROM person p
         LEFT JOIN company_1 c
                   ON p.company_id = c.id;

SELECT first_name || ' ' || last_name,
       c.name
FROM person p
         RIGHT JOIN company_1 c
                    ON p.company_id = c.id;

SELECT p.id,
       first_name || ' ' || last_name,
       c.id,
       c.name
FROM person p
         FULL JOIN company_1 c
                   ON p.company_id = c.id;


/*
 С агрегирующими функциями, которые обьеденяют наши строки sum, count, avg и т.д
 Используеются групировки запросов, и их регулировка с помощью операторов GROUP BY и HAVING

 Оператор GROUP BY определяет, как строки будут группироваться.
 Используется в операторе SELECT для сбора данных по нескольким записям и группировки результатов по одному или нескольким столбцам.

 Оператор HAVING определяет, какие группы будут включены в выходной результат, то есть выполняет фильтрацию групп.
 Используется в сочетании с оператором GROUP BY, чтобы ограничить группы возвращаемых строк только теми, чье условие TRUE.

 Если предложение WHERE определяет предикат для фильтрации строк, то предложение HAVING
 применяется после группировки для определения аналогичного предиката, фильтрующего группы по значениям агрегатных функций.

 Взор как должен выглядеть такой запрос:
 SELECT столбцы
 FROM таблица
 [WHERE условие_фильтрации_строк]
 [GROUP BY столбцы_для_группировки]
 [HAVING условие_фильтрации_групп]
 [ORDER BY столбцы_для_сортировки]
 */

SELECT c.id,
       c.name,
       count(company_id)
FROM person p
         RIGHT JOIN company_1 c
                    ON p.company_id = c.id
WHERE company_id IS NOT NULL
GROUP BY company_id, c.name, c.id
HAVING company_id > 1;


/*
 Оконная функция в SQL - функция, которая работает с выделенным набором строк (окном, партицией) и выполняет
 вычисление для этого набора строк в отдельном столбце.

 Партиции (окна из набора строк) - это набор строк, указанный для оконной функции по одному из столбцов или группе
 столбцов таблицы. Партиции для каждой оконной функции в запросе могут быть разделены по различным колонкам таблицы.

 Множество оконных функций можно разделять на 3 класса:
    Агрегирующие (Aggregate)
    Ранжирующие (Ranking)
    Функции смещения (Value)

 Агрегирующие:
    Можно применять любую из агрегирующих функций - SUM, AVG, COUNT, MIN, MAX

 В ранжирующих функция под ключевым словом OVER обязательным идет указание условия ORDER BY, по которому
 будет происходить сортировка ранжирования.
    ROW_NUMBER() - функция вычисляет последовательность ранг (порядковый номер) строк внутри партиции,
    НЕЗАВИСИМО от того, есть ли в строках повторяющиеся значения или нет.

    RANK() - функция вычисляет ранг каждой строки внутри партиции. Если есть повторяющиеся значения,
    функция возвращает одинаковый ранг для таких строчек, пропуская при этом следующий числовой ранг.

 Это функции, которые позволяют перемещаясь по выделенной партиции таблицы обращаться к предыдущему значению строки
 или крайним значениям строк в партиции.
    LAG() - функция, возвращающая предыдущее значение столбца по порядку сортировки.
 */

CREATE TABLE lesson
(
    id   SERIAL PRIMARY KEY,
    name TEXT NOT NULL UNIQUE
);

CREATE TABLE student
(
    id     SERIAL PRIMARY KEY,
    name   TEXT NOT NULL,
    female TEXT NOT NULL,
    lesson INT REFERENCES lesson,
    grade  INT  NOT NULL
);

INSERT INTO lesson (name)
VALUES ('Математика'),
       ('Английский'),
       ('Физкультура'),
       ('Рисование'),
       ('Физика');

INSERT INTO student (name, female, lesson, grade)
VALUES ('Петр', 'Петров', 1, 4),
       ('Петр', 'Петров', 2, 3),
       ('Петр', 'Петров', 3, 5),
       ('Петр', 'Петров', 4, 3),
       ('Петр', 'Петров', 5, 4),
       ('Маша', 'Сидорова', 1, 3),
       ('Маша', 'Сидорова', 2, 5),
       ('Маша', 'Сидорова', 3, 4),
       ('Маша', 'Сидорова', 4, 5),
       ('Маша', 'Сидорова', 5, 3);

SELECT s.name || ' ' || s.female,
       l.name,
       s.grade,
       avg(s.grade),
       min(s.grade),
       max(s.grade),
       rank() OVER (PARTITION BY s.id),
       row_number() OVER (PARTITION BY s.lesson)
       --lag() OVER (PARTITION BY s.id)
FROM student s
         JOIN lesson l on l.id = s.lesson
GROUP BY l.id, s.id;

/*
 В sql есть ткоая возможность как view, это чем-то похоже на таблицу, только представляет собой произведение,
 жтой таблицы которую можно таолько читать, а добавлять файлы или обновлять нельзя.

 Есть обычные представление, и материализованые

 View — это виртуальная таблица (представление). Она хранит результат выполнения SELECT запроса.
 С помощью вьюхи можно сохранить SELECT запрос и получить быстрый доступ к часто используемым данным.

 Материализованые - физически хранит данные, (имеет кэш этих данных) поэтому обращение к ним будет быстрее, но если
 вы добавите файл в таблицу, то это view не обновится, для этого создаются специальны джобы которые раз в какое-то время
 обновляют это view

 */

CREATE VIEW person_view
AS
SELECT c.name,
       p.first_name || ' ' || p.last_name
FROM company_1 c
         CROSS JOIN (SELECT * FROM person) p;

SELECT DISTINCT name
FROM person_view;


/*
 Чтобы не удалять и заново создавать таблицу как мы делали это ранее, мы можем ее обновлять.
 Чем чревато удаление и новое созадние? - потерей всех файлов

 Обновлять таблицу мы будет с помощью ключевого слова ALTER ЧТО МЫ ОБНОВЛЯЕМ { IF EXISTS } название

 IF EXISTS - нам гворит о том что если такой таблицы нету, то ошибка не выбросится
 */

ALTER TABLE IF EXISTS person
    ADD COLUMN sex CHAR(1);

UPDATE person
SET sex = 'f'
WHERE id < 5;

UPDATE person
SET sex = 'f'
WHERE id >= 5;

ALTER TABLE IF EXISTS person
    ALTER COLUMN sex
        SET NOT NULL;

SELECT sex,
       count(person.sex)
FROM person
GROUP BY sex;

SELECT first_name,
       last_name,
       sex
FROM person;


/*
 Когда мы используем select мы получаем какие-то данные, эти данные являются каким-то множеством(множеством строк)

 А так как это множества то с ними можно работать, можно получать совместные элементы, получать все данные
 одного множества и другие дургого и т.д
 Для этого у нас есть операции:

 UNION - добавляет в одно множество только те данные, которых нету (повторяющиеся не берет)
 UNION ALL - вставляет данные из одного множества в другое, внезависимости есть ли повторяющиеся элементы
 INTERSECT - пересечания двух множеств
 EXCEPT - исключает из множества те данные, которые повторяются в другом множестве
 */

CREATE SCHEMA day_6_schema;

VALUES (1, '2'),
       (2, '3'),
       (3, '4'),
       (4, '5'),
       (5, '6')
UNION
VALUES (4, '5'),
       (5, '6'),
       (6, '7'),
       (7, '8'),
       (8, '9')
ORDER BY 1;

VALUES (1, '2'),
       (2, '3'),
       (3, '4'),
       (4, '5'),
       (5, '6')
UNION ALL
VALUES (4, '5'),
       (5, '6'),
       (6, '7'),
       (7, '8'),
       (8, '9')
ORDER BY 1;

VALUES (1, '2'),
       (2, '3'),
       (3, '4'),
       (4, '5'),
       (5, '6')
INTERSECT
VALUES (4, '5'),
       (5, '6'),
       (6, '7'),
       (7, '8'),
       (8, '9')
ORDER BY 1;

VALUES (1, '2'),
       (2, '3'),
       (3, '4'),
       (4, '5'),
       (5, '6')
EXCEPT
VALUES (4, '5'),
       (5, '6'),
       (6, '7'),
       (7, '8'),
       (8, '9')
ORDER BY 1;


/*
 Если мы ищем какой-то один элемент в таблице, то база данных использует full-scan(проходится по каждой записи,
 и сравнивает является ли даная запись искомой записью которую мы ищем). И если у нас база данных маленькая
 то и поиск будет проходить быстроЮ но если у нас многомилионная база данных, то чтобы найти искомый элемент
 нужно будет искать по целой таблице. Для этого в sql есть индексы

 Индекс - это условные таблицы, но на самом деле это обькты базы данных используемые поисковыми системами
 для поиска данных.
 Пример:
 Если мы ищем какого-то человека по имени и фамилии в списке, то мы будет искать его по первой букве фамилии,
 потом по 2 и пока не найдем искомого человека.

 Так и базы данных отталкиваясь от индексов ищут искомые элементы.

 Самые полпулярные типы индексов, это индексы B-TREE - https://en.algorithmica.org/hpc/data-structures/s-tree/
 Суть B-TREE состоит из узлов и корня, при поиске начальная точка будет составлена из всех корней.
 У каждого корня есть узлы (2) которые находятся между корнями. То-есть если у корня 1 есть последний узол, то этот
 последний узол будет первым у следующего узла. Если корней 4, то узлов будет 5.

 Пример: Нужно найти число 25

      10      15      20       30
     /       /       /        /
    1 7 5   12 13   16 19   21 23 25 26

 База данных будет двигатся по индексам и сравнивать:
 25 > или < 10? = > идем дальше
  25 > или < 15? = > идем дальше
  25 > или < 20? = > идем дальше

  25 > или < 30? = < идем на первый узол

 Переходим к детенышу корня 30

  25 > или < 21? = > идем дальше
  25 > или < 23? = > идем дальше

  25 > или < 25? = 25 мы нашли 25

 На жеском диске каждый корень со своими детенышми находится в так сказть определнной точке в памяти,
 и база данных будет сканировать так каждую эту точку, и с 1 двигатся в дургую, пока не найдет искомы элемент

 Еще индекс может быть ссылкой на файл, или сам в себе держать искомый файл

 Селективность - это кол-во уникальных элементов на общее кол-во записей в таблице, чем ближе оно к 1 тем лучше
 9/55 = 0,16 - селективность очень плохая
 55/55 = 1 - селективность идеальная

 Так єе не стоит разбрасываться индексами, так как если мы что0то захотим изменить в таблице, то после изменения
 должно пройти полное изменение всех индексов, а это тоже занимает время
 */

CREATE TABLE books
(
    id          SERIAL PRIMARY KEY,
    name_book   TEXT UNIQUE NOT NULL,
    year_public INT         NOT NULL,
    pages       INT         NOT NULL,
    writer_id   INT REFERENCES writer ON DELETE CASCADE
);


CREATE TABLE writer
(
    id      SERIAL PRIMARY KEY,
    name    TEXT NOT NULL,
    surname TEXT NOT NULL,
    UNIQUE (name, surname)
);

INSERT INTO writer (name, surname)
VALUES ('Лев', 'Толстой'),
       ('Тарас', 'Шевченко'),
       ('Николай', 'Гоголь'),
       ('Михаил', 'Булгаков'),
       ('Артур', 'Конан-Дойл');

INSERT INTO books (name_book, year_public, pages, writer_id)
VALUES ('Война и Мир', 1865, 1300, 1),
       ('Анна Каррели', 1877, 864, 1),
       ('Детство', 1855, 200, 1),
       ('Кобзар', 1840, 224, 2),
       ('Катерина', 1840, 40, 2),
       ('Завешание', 1859, 416, 2),
       ('Мертвые души', 1842, 248, 3),
       ('Тарас Бульба', 1835, 320, 3),
       ('Мастер и Маргарита', 1967, 416, 4),
       ('Собачье Сердцу', 1925, 256, 4),
       ('Шерлок Холмс', 1892, 448, 5),
       ('Затеряный мир', 1912, 320, 5);

CREATE INDEX book_id ON books (id, writer_id);

SELECT *
FROM books b
         LEFT JOIN writer w
                   ON w.id = b.writer_id
WHERE b.id = 5;


/*

 НЕ ОБЯЗАТЕЛЬНО ЧИТАТЬ

 План выполнения запросов в субд на сегодняшнее время является стоимостным(раньше был синтаксический)

 Сам этот стоимостной план выполнения состоит из

 page_cost(input-output) = 1.0 - кол-во байтов которые занимает одна страница, всегда = 1
 cpu_cost - 0.01 - кол-во строк в таблице

 В даном случае у нас есть 12 строк, и 1 страница поэтому:
 cpu_cost = 12 * 0.01 = 0.12
 page_cost = 1.0

 Субд берет эти данны из таблицы pg_catalog -> tables -> pg_class

 rows - указывает кол-во строк (не всегла верно)
 width - определяет обьекм диска для базы данных так, что указывает сумарнуе кол-во байтов которое занимает 1 строка

       reltuples - указывать сколько строк
       relkind - говорит какой тип этих записей в данном случае строки
       relpage - указывает кол-во страниц

  Информация в pg_catalog обновляется раз в како-ето время, поэтоу информация не всегда актуальна


  Планы выполнения запросов в индексах:

  1.Самая базовая операция – это последовательное сканирование (Seq Scan).
  Это самая простая операция из всех возможных – PostgreSQL открывает файл с таблицей,
  читает строки одну за другой и возвращает их пользователю или расположенному выше узлу дерева explain

  2.Следующий тип узла — “Index Scan".
  Всё просто – у нас есть индекс, соответствующий условию, так что PostgreSQL:
    - Открывает индекс;
    - В индексе, если находит, где (в данных таблицы) могут быть строки, соответствующие данному условию:
        - открывает таблицу;
        - получает строку(-и), указанную(-ые) индексом;
    - Если строки могут быть возвращены – то есть, если они видимы в текущей сессии – они возвращаются.

  3.Ещё одна схожая операция — “Index Only Scan".
  Обратите внимание на слово “Only" в “Index Only Scan".
  Это значит, что Постгрес понял, что я выбираю только данные (колонки) из индекса.
  И, возможно, ему не нужно ничего проверять в файлах таблицы. Так что он будет возвращать данные прямо из индекса.

  4.Последний тип сканирования таблицы – так называемый Bitmap Index Scan.
  Bitmap Scans всегда состоят, минимум, из двух узлов. Сначала (на нижнем уровне) идет Bitmap Index Scan,
  а затем – Bitmap Heap Scan.

  Допустим, в вашей таблице 100000 страниц (это около 780MB). Bitmap Index Scan создаст битовую карту,
  где каждой странице вашей таблицы будет соответствовать один бит.
  Так что, в этом случае мы получим блок памяти на 100,000 бит ~ 12.5 кБ. Все эти биты будут установлены в 0.
  Затем, Bitmap Index Scan установит некоторые биты в 1, в зависимости от того,
  на какой странице таблицы может находиться строка, которую нужно вернуть.

  Эта часть вообще не затрагивает данные в таблице. После того как это будет сделано – то есть когда все страницы,
  на которых находятся строки, которые нужно вернуть, будут «помечены» – эта битовая карта перейдет на уровень выше,
  к узлу Bitmap Heap Scan, который читает их в более последовательной манере.



  Планы выполнения запросов в джоинах:

  1.Hash Join / Hash
  Hash Join имеет 2 субоперации. Одна из них всегда “Hash", а вторая – что-нибудь другое.
  Как понятно из названия, Hash Join используется для объединения двух наборов записей.

  Сначала Hash Join вызывает “Hash", который в свою очередь вызывает что-нибудь ещё.
  Потом Hash создает в памяти (или на диске – в зависимости от размера) хэш/ассоциативный массив/словарь со строками
  из источника, хэшированными с помощью того, что используется для объединения данных.

  Потом Hash Join запускает вторую субоперацию (Seq Scan по pg_class в нашем случае) и, для каждой строки из неё, делает следующее:
    - Проверяет, есть ли ключ join в хэше, возвращенном операцией Hash.
    - Если нет, данная строка из субоперации игнорируется (не будет возвращена).
    - Если ключ существует, Hash Join берет строки из хэша и, основываясь на этой строке, с одной стороны,
      и всех строках хэша, с другой стороны, генерирует вывод строк.

 Важно отметить, что обе стороны join выполняются всего один раз, но сначала та, что была вызвана операцией Hash,
 должна вернуть все строки, которые хранились в хэше, а вторая обрабатывается построчно,
 и некоторые строки будут пропущены, если они не существуют в хэше первой стороны.

  2.Nested Loop
  Это очень интересный план, потому что он может выполнять выбранные операции неоднократно.
  Так же, как и у Hash Join, у Nested Loop есть двое «потомков». Сначала она запускает “Seq Scan",
  а затем, для каждой возвращенной строки, она запускает вторую операцию.

  Давайте рассмотрим следующий план из explain.depesz.com.
  Заметьте, что фактическое время выполнения для всех операций index scan для categories – от 0.002 до 0.003мс.
  Но общее время, затраченное на этот узел – 78.852мс, потому что это сканирование индекса выполнялось более 26k раз.

 Так что обработка выглядит следующим образом:
    - Nested Loop запускает первую сторону объединения единожды. Давайте назовем её “A".
    - Для каждой строки из “A", запускается вторая операция (назовём её “B").
    - Если “B" не вернула ни одной строки, данные из “A" игнорируются.
    - Если “B" вернула строки, для каждой возвращаемой строки Nested Loop возвращает новую строку,
      основанную на текущих строках из A и B.

  3.Merge Join
  Еще один метод объединения данных называется Merge Join. Он используется, если объединяемые наборы данных отсортированы
  (или могут быть отсортированы с небольшими затратами) с помощью ключа join.

  Merge Join, как и другие объединения, запускает две субоперации.
  Так как они обе возвращают данные отсортированными и порядок сортировки такой же, как в операции объединения,
  Pg может сканировать оба набора данных, возвращенных субоперациями, одновременно и просто проверить,
  совпадают ли идентификаторы.

Процедура выглядит следующим образом:
    Eсли объединяемый столбец справа такой же, как объединяемый столбец слева:
        - возвращаем новую объединённую строку, основанную на текущих строках справа и слева;
        - берем следующую строку справа (или слева, если справа больше нет строк);
        - возвращаемся к шагу 1;
    Eсли объединяемый столбец справа «меньше», чем объединяемый столбец слева:
        - берем следующую строку справа (если строк больше нет, заканчиваем обработку);
        - возвращаемся к шагу 1;
    Eсли объединяемый столбец справа «больше», чем объединяемый столбец слева:
        - берем следующую строку слева (если строк больше нет, заканчиваем обработку);
        - возвращаемся к шагу 1.
 */


/**
 В субд при каждом запросе, добавлении, удалении, обновлении и т.д всегда открываются транзакции.

 Они работают таким образом, что они или полностью выполняются, или полностью откатываются.
 То есть если 1 транзакция выполнила свое, а другая нет то они обе откатятся, так-как должны выполнится все, или ни одна.

 Транзакция должна обладаться следующими свойтсвами ACID
 1. Atomicity - Атомарность гарантирует что никакая транзакция будт зафиксирована в системе частично (то что выше)
       - Будут выполнены все операции, либо ни одной.
 2. Consistency - каждая успешная транзакция фиксирует только допустимые результаты
 3. Isolation - изолированость - ни одна транзакция не должна повлиять на выполнения другой.
 4. Durability - устойчивость - независимо от проблем на ниждем уровне, сделаные изменения которые успешно
 были завершены, должны сохранится в базе данных

 Учитывая тот факт, что транзакции могу работать с одной базой данных парарельно, у нас могут возникнуть проблемы
 1.Lost update - потеряное обновление - происходит, когда обе транзакции одновременное обновляют данные, но потом одна
   одна из них откатывает изменения, вследствии чего обновления обоих транзакций теряются
   (В современных субд это не случится)

 2.Dirty Read - грязное чтение - проиходит когда первая транзакция читает изменения, сделанные другой транзакцей, но
   эти изменения еще не были завершены. После этого вторая тран. откатывает изменения,
   а первая продолжает работу с этими грязными данными (В современных субд очень малый случай что оно случится)

 3.Non Repeatable Read - неповторяющеися чтение - происходит когда одно и та же транзакция читает одни и те же данные
 дважды, но после первого прочтения, вторая транзакция изменяет(update) эти же данные + коммитит, вследствии чего
 вторая выборка в первой транзакции вернет другой результат

   - Существет еще особый случай Non Repeatable Read, который называется last commit wins - если коротко то если
   вы и еще один человек одновременно хотите забронировать номер, вы его забронировали но изменения еще не успели
   произойти, и другой человек успел тоже забронировать номер, то вследствии чего ваши изменения(бронировние) теряется

 4.Phantom Read - фантомное чтение - происходит когда одна транзакция читает одни и те же данные дважды, но после
 первого прочтения вторая транзакция добавляет новые строки, или удаляет старые (Insert, delete), вследствии чего
 вторая выборка в первой транзакции вернет другой результат (или разное кол-во записей)

 Так-же чтобы от этого избавится нудно создавать изолированые транзакции.
 Уровни изолирования транзакций:
 SERIALIZABLE - изолирует от всего
 REPEATABLE READ - изолирует от всего кроме фантомного чтения
 READ COMMITTED - изолирует от грязного чтения и потеряного обновления
 READ UNCOMMITTED - изолирует только от потеряного обновления

 Однако в Postgres используется только READ COMMITTED и SERIALIZABLE,
 тогда при попытке использования READ UNCOMMITTED вызовется READ COMMITTED,
 а при попытке использования REPEATABLE READ вызовется SERIALIZABLE
*/


/**
  Тригерры это отдельные обьекты sql которые позволяют нам отслеживать изменения удаления, обновлнеия днных в таблицах.
  Для этого нам нужно создать функция которая будет возвращать на тригер, а потом на основе этой функции
  создать уже сам тригер.

  Тригер при отслеживании действий в таблице, сам может что-то делать до, после,
  или заменить например втсавку (если это вставка)
 */

CREATE TABLE employee
(
    id      SERIAL PRIMARY KEY,
    name    VARCHAR(128) NOT NULL,
    surname VARCHAR(128) NOT NULL,
    salary  INT
);

CREATE TABLE audit
(
    id         INT,
    table_name TEXT,
    date       TIMESTAMP
);

CREATE FUNCTION audit_function() RETURNS TRIGGER
    LANGUAGE plpgsql
AS
$$
BEGIN
    insert into audit (id, table_name, date)
    VALUES (new.id, tg_table_name, now());
    return null;
END;
$$;

CREATE TRIGGER audit_employee_trigger
    BEFORE UPDATE OR DELETE OR INSERT
    ON employee
    FOR EACH ROW
EXECUTE FUNCTION audit_function();


INSERT INTO employee (name, surname, salary)
VALUES ('Anrii', 'Synko', 3000),
       ('Jakub', 'Varga', 1200),
       ('Ruslan', 'Prodan', 2000),
       ('Ruslan', 'Ursta', 1500),
       ('Anton', 'Penzeshtadler', 700),
       ('Andriy', 'Jancikn', 1700),
       ('Matey', 'Slnek', 900),
       ('Tomas', 'Moravcik', NULL),
       ('Tomas', 'Labar', NULL),
       ('Danil', 'Atukmaiev', NULL);
SELECT *
FROM audit;



/**

  BigQuery

  DWH - это хранилище которое хранит только нужные данные для компании, на основании которых будет проводится
  анализ и принятие базнес решений

  Отличия между DWH и обычними бащами данных:

  1.Обачные СУБД хранят данные строго под какие-то подсистемы
  Например баща данных task_books хранит данные о книгах, а flight_repository хранит данные о перелетах
  А DWN хранит данные из разным областей, которые каким-либо образом относятся к бизнесу

  2.Обычные СУБД ипользуются для хранения актуальной информации, чтобы определенная система
  корректно работала в нужный момент времени.
  А в DWH могут хранится копии данных (иногда и копии целых баз данных), а также историчиские данные и агрегированые
  значения

  Процес заполнения данными:
  Информации почти сразу попадает в класическуб нам СУБД, а оттуда переходит в DWH, но перед этим проходит
  обработку и преобразование. По сути DWH отражает состояние других БД уже после того как в них внесутся изменения

  То есть из источников(неважно каких) данные попадают в СУБД потом они обрабатываются с помощтю ETL
  (Extract, Transform, Load) - извлечение, трансформирование, загруза в DWH
 */


-------- Lesson 2 --------------

/*
 Если у нас есть система какая работает на основе нашей базы данных, то если с нашец базой данных что-то случится
 то вся система для всех пользователей перестанет работать. Чтобы это устранить используется копирование базы.

 Репликация баз данных - процес который копирует данные из одного источника в другой/другие ил наоборот.
 Репликация может быть
    - синхронной(происходит в той же транзакции практически срауз) - при отправлении запроса база будет ждать
        возвращение этого запроса из всех копий, и только тогда выполнит наш запрос
    - асинхронной(происходит спустя какое-то время в разных транзакциях) - при отправлении баща не ждет совместного
        возвращения данных запроса, а сразу возвращает данные с копии, что позволяет улучшить производительность

 Репликая может выполнатся с помощью:
    - Master - Slave - Master отвечает за все, он выполняет все запросы на изменеия, удаление, добавление,
    а Slave доступны только запросы на чтение

    - Master - Master - Каждя из реплик самостоятельна, может выполнять запросы на удаление изменение и т.д

 Если у нас очень большое кол-во данных то мы используем Фрагментацию или сегментацию базы данных -
 это процесс розделения одной больщой базы на несколько более мелких автономных разделов. Каждый раздел имеет
 одинаковую схему и столбцы, но разные сроки. Данные хранящиеся в каждом из низ уникальны и не зависят от данных
 хранящихся в других разделах

 Так же можно комбинировать и репликацию и фрагментацию вместе и получать конструкции которые называются
 Распределенная база данных - это ьаза в которой составные часим находятся в разных узлах компьтерной сети в соотвествии
 каким-то критериям.

 Вследствии этого у нас появляется купа проблем, и есть теорема которое это опиывает

 Теорема CAP - это теорема утверждающая что при разработаке распределнной системы вы не можете достичь одновременно
 трех свойст:
 Согласованость - каждое чтение дает нам самую последнюю запись
 Доступность - система всгда успешно выполнчет запросы, даже если имеются упавшие узлы
 Устойчивость к разделению - даже если между узлами пропала связь они продолжат рабоать независимо друг от друга,
    и продолжат выполнять запросы

 Вы одновременно можете выбрать только два из трех но никак не всех сразу

 NoSQL - нереляционные базф данных которые специально предназначены для работы в рампределнных системах, с большим
 обьемом данных, которые не помещаются в один узел

 Основные типы NoSQL:
 - БД на основе пар ключ значение
 - Документно-ориентированые БД
 - Графовые
 - БД в памяти
 - Поисковые БД
 */
