----------------- Day 6 ------------------------

----- Lesson 1 --------------------

/*
 Когда мы используем select мы получаем какие-то данные, эти данные являются каким-то множеством(множеством строк)

 А так как это множества то с ними можно работать, можно получать совместные элементы, получать все данные
 одного множества и другие дургого и т.д
 Для этого у нас есть операции:

 UNION - добавляет в одно множество только те данные, которых нету (повторяющиеся не берет)
 UNION ALL - вставляет данные из одного множества в другое, внезависимости есть ли повторяющиеся элементы
 INTERSECT - пересечания двух множеств
 EXCEPT - исключает из множества те данные, которые повторяются в другом множестве
 */

CREATE SCHEMA day_6_schema;

VALUES (1,'2'), (2,'3'), (3,'4'), (4,'5'), (5,'6')
UNION
VALUES (4,'5'), (5,'6'), (6,'7'), (7,'8'),(8,'9')
ORDER BY 1;

VALUES (1,'2'), (2,'3'), (3,'4'), (4,'5'), (5,'6')
UNION ALL
VALUES (4,'5'), (5,'6'), (6,'7'), (7,'8'),(8,'9')
ORDER BY 1;

VALUES (1,'2'), (2,'3'), (3,'4'), (4,'5'), (5,'6')
INTERSECT
VALUES (4,'5'), (5,'6'), (6,'7'), (7,'8'),(8,'9')
ORDER BY 1;

VALUES (1,'2'), (2,'3'), (3,'4'), (4,'5'), (5,'6')
EXCEPT
VALUES (4,'5'), (5,'6'), (6,'7'), (7,'8'),(8,'9')
ORDER BY 1;



-------------------- Lesson 2,3 ---------------

/*
 Если мы ищем какой-то один элемент в таблице, то база данных использует full-scan(проходится по каждой записи,
 и сравнивает является ли даная запись искомой записью которую мы ищем). И если у нас база данных маленькая
 то и поиск будет проходить быстроЮ но если у нас многомилионная база данных, то чтобы найти искомый элемент
 нужно будет искать по целой таблице. Для этого в sql есть индексы

 Индекс - это условные таблицы, но на самом деле это обькты базы данных используемые поисковыми системами
 для поиска данных.
 Пример:
 Если мы ищем какого-то человека по имени и фамилии в списке, то мы будет искать его по первой букве фамилии,
 потом по 2 и пока не найдем искомого человека.

 Так и базы данных отталкиваясь от индексов ищут искомые элементы.

 Самые полпулярные типы индексов, это индексы B-TREE - https://en.algorithmica.org/hpc/data-structures/s-tree/
 Суть B-TREE состоит из узлов и корня, при поиске начальная точка будет составлена из всех корней.
 У каждого корня есть узлы (2) которые находятся между корнями. То-есть если у корня 1 есть последний узол, то этот
 последний узол будет первым у следующего узла. Если корней 4, то узлов будет 5.

 Пример: Нужно найти число 25

      10      15      20       30
     /       /       /        /
    1 7 5   12 13   16 19   21 23 25 26

 База данных будет двигатся по индексам и сравнивать:
 25 > или < 10? = > идем дальше
  25 > или < 15? = > идем дальше
  25 > или < 20? = > идем дальше

  25 > или < 30? = < идем на первый узол

 Переходим к детенышу корня 30

  25 > или < 21? = > идем дальше
  25 > или < 23? = > идем дальше

  25 > или < 25? = 25 мы нашли 25

 На жеском диске каждый корень со своими детенышми находится в так сказть определнной точке в памяти,
 и база данных будет сканировать так каждую эту точку, и с 1 двигатся в дургую, пока не найдет искомы элемент

 Еще индекс может быть ссылкой на файл, или сам в себе держать искомый файл

 Селективность - это кол-во уникальных элементов на общее кол-во записей в таблице, чем ближе оно к 1 тем лучше
 9/55 = 0,16 - селективность очень плохая
 55/55 = 1 - селективность идеальная

 Так єе не стоит разбрасываться индексами, так как если мы что0то захотим изменить в таблице, то после изменения
 должно пройти полное изменение всех индексов, а это тоже занимает время
 */

CREATE TABLE books
(
    id          SERIAL PRIMARY KEY,
    name_book   TEXT UNIQUE NOT NULL,
    year_public INT         NOT NULL,
    pages       INT         NOT NULL,
    writer_id   INT REFERENCES writer ON DELETE CASCADE
);


CREATE TABLE writer
(
    id      SERIAL PRIMARY KEY,
    name    TEXT NOT NULL,
    surname TEXT NOT NULL,
    UNIQUE (name, surname)
);

INSERT INTO writer (name, surname)
VALUES ('Лев','Толстой'),
       ('Тарас','Шевченко'),
       ('Николай','Гоголь'),
       ('Михаил','Булгаков'),
       ('Артур','Конан-Дойл');

INSERT INTO books (name_book, year_public, pages, writer_id)
VALUES ('Война и Мир',1865,1300,1),
       ('Анна Каррели',1877,864,1),
       ('Детство',1855,200,1),
       ('Кобзар',1840,224,2),
       ('Катерина',1840,40,2),
       ('Завешание',1859,416,2),
       ('Мертвые души',1842,248,3),
       ('Тарас Бульба',1835,320,3),
       ('Мастер и Маргарита',1967,416,4),
       ('Собачье Сердцу',1925,256,4),
       ('Шерлок Холмс',1892,448,5),
       ('Затеряный мир',1912,320,5);

CREATE INDEX book_id ON books (id, writer_id);

SELECT *
FROM books b
    LEFT JOIN writer w
        ON w.id = b.writer_id
WHERE b.id = 5;


------------ Lesson 4 ----------------

/*
 План выполнения запросов в субд на сегодняшнее время является стоимостным(раньше был синтаксический)
 */

explain select *
from books;
/*
 Сам этот стоимостной план выполнения состоит из

 page_cost(input-output) = 1.0 - кол-во байтов которые занимает одна страница, всегда = 1
 cpu_cost - 0.01 - кол-во строк в таблице

 В даном случае у нас есть 12 строк, и 1 страница поэтому:
 cpu_cost = 12 * 0.01 = 0.12
 page_cost = 1.0

 Субд берет эти данны из таблицы pg_catalog -> tables -> pg_class

 rows - указывает кол-во строк (не всегла верно)
 width - определяет обьекм диска для базы данных так, что указывает сумарнуе кол-во байтов которое занимает 1 строка
 */
select reltuples,
       relkind,
       relpages
from pg_class
where relname = 'books';

/**
       reltuples - указывать сколько строк
       relkind - говорит какой тип этих записей в данном случае строки
       relpage - указывает кол-во страниц

  Информация в pg_catalog обновляется раз в како-ето время, поэтоу информация не всегда актуальна
 */
