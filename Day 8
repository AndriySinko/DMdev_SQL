------------------------------------- Day 8 ---------------------------------------------

--------------- Lesson 1,2 ----------------------

/**
  В субд при каждом запросе, добавлении, удалении, обновлении и т.д всегда открываются транзакции.

  Они работают таким образом, что они или полностью выполняются, или полностью откатываются.
  То есть если 1 транзакция выполнила свое, а другая нет то они обе откатятся, так-как должны выполнится все, или ни одна.

  Транзакция должна обладаться следующими свойтсвами ACID
  1. Atomicity - Атомарность гарантирует что никакая транзакция будт зафиксирована в системе частично (то что выше)
        - Будут выполнены все операции, либо ни одной.
  2. Consistency - каждая успешная транзакция фиксирует только допустимые результаты
  3. Isolation - изолированость - ни одна транзакция не должна повлиять на выполнения другой.
  4. Durability - устойчивость - независимо от проблем на ниждем уровне, сделаные изменения которые успешно
  были завершены, должны сохранится в базе данных

  Учитывая тот факт, что транзакции могу работать с одной базой данных парарельно, у нас могут возникнуть проблемы
  1.Lost update - потеряное обновление - происходит, когда обе транзакции одновременное обновляют данные, но потом одна
    одна из них откатывает изменения, вследствии чего обновления обоих транзакций теряются
    (В современных субд это не случится)

  2.Dirty Read - грязное чтение - проиходит когда первая транзакция читает изменения, сделанные другой транзакцей, но
    эти изменения еще не были завершены. После этого вторая тран. откатывает изменения,
    а первая продолжает работу с этими грязными данными (В современных субд очень малый случай что оно случится)

  3.Non Repeatable Read - неповторяющеися чтение - происходит когда одно и та же транзакция читает одни и те же данные
  дважды, но после первого прочтения, вторая транзакция изменяет(update) эти же данные + коммитит, вследствии чего
  вторая выборка в первой транзакции вернет другой результат

    - Существет еще особый случай Non Repeatable Read, который называется last commit wins - если коротко то если
    вы и еще один человек одновременно хотите забронировать номер, вы его забронировали но изменения еще не успели
    произойти, и другой человек успел тоже забронировать номер, то вследствии чего ваши изменения(бронировние) теряется

  4.Phantom Read - фантомное чтение - происходит когда одна транзакция читает одни и те же данные дважды, но после
  первого прочтения вторая транзакция добавляет новые строки, или удаляет старые (Insert, delete), вследствии чего
  вторая выборка в первой транзакции вернет другой результат (или разное кол-во записей)

  Так-же чтобы от этого избавится нудно создавать изолированые транзакции.
  Уровни изолирования транзакций:
  SERIALIZABLE - изолирует от всего
  REPEATABLE READ - изолирует от всего кроме фантомного чтения
  READ COMMITTED - изолирует от грязного чтения и потеряного обновления
  READ UNCOMMITTED - изолирует только от потеряного обновления

  Однако в Postgres используется только READ COMMITTED и SERIALIZABLE,
  тогда при попытке использования READ UNCOMMITTED вызовется READ COMMITTED,
  а при попытке использования REPEATABLE READ вызовется SERIALIZABLE
 */


--------------- Lesson 3 ----------------------

/**
  Тригерры это отдельные обьекты sql которые позволяют нам отслеживать изменения удаления, обновлнеия днных в таблицах.
  Для этого нам нужно создать функция которая будет возвращать на тригер, а потом на основе этой функции
  создать уже сам тригер.

  Тригер при отслеживании действий в таблице, сам может что-то делать до, после,
  или заменить например втсавку (если это вставка)
 */

CREATE SCHEMA day_8_schema;
CREATE TABLE employee
(
    id         SERIAL PRIMARY KEY,
    name       VARCHAR(128) NOT NULL,
    surname    VARCHAR(128) NOT NULL,
    salary     INT
);

CREATE TABLE audit (
    id INT,
    table_name TEXT,
    date TIMESTAMP
);

CREATE FUNCTION audit_function() RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
    BEGIN
        insert into audit (id, table_name, date)
        VALUES (new.id, tg_table_name,now());
        return null;
    END;
$$;

CREATE TRIGGER audit_employee_trigger
    BEFORE UPDATE OR DELETE OR INSERT
    ON employee
    FOR EACH ROW
    EXECUTE FUNCTION audit_function();


INSERT INTO employee (name, surname,salary)
VALUES ('Anrii', 'Synko',  3000),
       ('Jakub', 'Varga',  1200),
       ('Ruslan', 'Prodan', 2000),
       ('Ruslan', 'Ursta',  1500),
       ('Anton', 'Penzeshtadler', 700),
       ('Andriy', 'Jancikn', 1700),
       ('Matey', 'Slnek', 900),
       ('Tomas', 'Moravcik', NULL ),
       ('Tomas', 'Labar', NULL),
       ('Danil', 'Atukmaiev', NULL);
SELECT *
FROM audit;
